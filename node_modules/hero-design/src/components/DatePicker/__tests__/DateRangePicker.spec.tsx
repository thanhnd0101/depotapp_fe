import React from 'react';
import { waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import renderWithTheme from '../../../testUtils/renderWithTheme';

import DateRangePicker from '../DateRangePicker';

describe('rendering', () => {
  it('renders two inputs and calendar', async () => {
    const {
      getByDisplayValue,
      getAllByDisplayValue,
      getAllByText,
    } = renderWithTheme(
      <DateRangePicker
        value={{
          startDate: '02/05/2021',
          endDate: '10/05/2021',
        }}
      />
    );

    await waitFor(() => {
      expect(getByDisplayValue('02/05/2021')).toBeInTheDocument();
      expect(getByDisplayValue('10/05/2021')).toBeInTheDocument();
    });

    userEvent.click(getByDisplayValue('02/05/2021'));

    await waitFor(() => {
      expect(getByDisplayValue('May')).toBeVisible();
      expect(getByDisplayValue('Jun')).toBeVisible();
      expect(getAllByDisplayValue('2021').length).toBe(2);
      expect(getAllByText('10').length).toBe(3);
    });
  });

  it('renders two inputs with correct format', async () => {
    const { getByDisplayValue } = renderWithTheme(
      <DateRangePicker
        value={{
          startDate: '2021/05/02',
          endDate: '2021/05/10',
        }}
        format="yyyy/MM/dd"
      />
    );

    await waitFor(() => {
      expect(getByDisplayValue('2021/05/02')).toBeInTheDocument();
      expect(getByDisplayValue('2021/05/10')).toBeInTheDocument();
    });
  });
});

describe('interaction', () => {
  it('allows to pick start date and then end date', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText, queryByText } = renderWithTheme(
      <DateRangePicker
        value={{
          startDate: '02/05/2021',
          endDate: '10/05/2021',
        }}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('Start'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Su')[0]).toBeVisible();
    });

    userEvent.click(getAllByText('9')[0]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '09/05/2021',
        endDate: '10/05/2021',
      });
      // Calendar is still open
      expect(getAllByText('Su')[1]).toBeVisible();
    });

    userEvent.click(getAllByText('15')[0]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(2);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '02/05/2021',
        endDate: '15/05/2021',
      });
      // Calendar is closed
      expect(queryByText('Su')).not.toBeInTheDocument();
    });
  });

  it('allows to pick end date and then start date', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText, queryByText } = renderWithTheme(
      <DateRangePicker
        value={{
          startDate: '02/05/2021',
          endDate: '10/05/2021',
        }}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('End'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Su')[0]).toBeVisible();
    });

    userEvent.click(getAllByText('9')[0]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '02/05/2021',
        endDate: '09/05/2021',
      });
      // Calendar is still open
      expect(getAllByText('Su')[1]).toBeVisible();
    });

    userEvent.click(getAllByText('8')[0]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(2);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '08/05/2021',
        endDate: '10/05/2021',
      });
      // Calendar is closed
      expect(queryByText('Su')).not.toBeInTheDocument();
    });
  });

  it('resets end date when new start date is after end date', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText } = renderWithTheme(
      <DateRangePicker
        value={{
          startDate: '02/05/2021',
          endDate: '10/05/2021',
        }}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('Start'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Su')[0]).toBeVisible();
    });

    userEvent.click(getAllByText('12')[0]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith({
        startDate: '12/05/2021',
        endDate: undefined,
      });
      // Calendar is still open
      expect(getAllByText('Su')[1]).toBeVisible();
    });
  });

  it('resets start date when new end date is before start date', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText } = renderWithTheme(
      <DateRangePicker
        value={{
          startDate: '02/05/2021',
          endDate: '10/05/2021',
        }}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('End'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Su')[0]).toBeVisible();
    });

    userEvent.click(getAllByText('1')[0]);

    await waitFor(() => {
      expect(onChange).toHaveBeenCalledTimes(1);
      expect(onChange).toHaveBeenCalledWith({
        startDate: undefined,
        endDate: '01/05/2021',
      });
      // Calendar is still open
      expect(getAllByText('Su')[1]).toBeVisible();
    });
  });

  it('does not allow to pick a date out of range', async () => {
    const onChange = jest.fn();
    const { getByPlaceholderText, getAllByText } = renderWithTheme(
      <DateRangePicker
        value={{
          startDate: '11/05/2021',
          endDate: '15/05/2021',
        }}
        minDate={new Date(2021, 4, 10)}
        maxDate={new Date(2021, 4, 20)}
        onChange={onChange}
        placeholder={{ startDate: 'Start', endDate: 'End' }}
      />
    );

    userEvent.click(getByPlaceholderText('Start'));

    await waitFor(() => {
      // Calendar is open
      expect(getAllByText('Su')[0]).toBeVisible();
    });

    await waitFor(() => {
      expect(() => userEvent.click(getAllByText('1')[0])).toThrowError(
        'unable to click element as it has or inherits pointer-events set to "none"'
      );
    });

    await waitFor(() => {
      expect(() => userEvent.click(getAllByText('21')[0])).toThrowError(
        'unable to click element as it has or inherits pointer-events set to "none"'
      );
    });
  });

  it('does not allow to edit disabled DateRangePicker', async () => {
    const { queryByText, getByDisplayValue } = renderWithTheme(
      <DateRangePicker
        value={{
          startDate: '11/05/2021',
          endDate: '15/05/2021',
        }}
        disabled
      />
    );

    userEvent.click(getByDisplayValue('11/05/2021'));

    await waitFor(() => {
      expect(queryByText('Su')).not.toBeInTheDocument();
    });
  });

  it('does not allow invalid value', () => {
    jest.spyOn(console, 'error').mockImplementation(() => '');

    expect(() =>
      renderWithTheme(
        <DateRangePicker
          value={{
            startDate: '1111/05/2021',
            endDate: '15111/05/2021',
          }}
        />
      )
    ).toThrowError('Invalid time value');
  });
});
