import React, {
  ReactElement,
  ReactNode,
  ChangeEvent,
  KeyboardEvent,
  useRef,
  useState,
  useCallback,
  useEffect,
  useMemo,
  CSSProperties,
  FocusEvent,
} from 'react';
import Downshift from 'downshift';

import Input from '../Input';
import Menu from '../Menu';
import Typography from '../Typography';
import Divider from '../Divider';
import Dropdown from '../Dropdown';
import SuffixIcon from './SuffixIcon';
import { IconName } from '../Icon';
import {
  SelectWrapper,
  InputWrapper,
  MenuWrapper,
  CategoryWrapper,
} from './StyledSelect';
import {
  checkAtBottom,
  getItemOffsetTop,
  mapOptions,
  optionPredicate,
  Option as OptionType,
  filterGroupedOptions,
  getAccumulatedIndex,
} from './utils';
import { pipe, noop } from '../../fp/function';
import { fromNullable, map, getOrElse } from '../../fp/Option';
import { map as arrayMap, flat } from '../../fp/Array';
import { useResizeObserver } from '../../utils/hooks';

import { CommonProps } from '../common';

export interface SelectProps extends CommonProps {
  /**
   * Specify the [automated assistance](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete) in filling out form field values by the browser.
   */
  autoComplete?: string;
  /**
   * Allow to clear value after selecting an item.
   */
  clearable?: boolean;
  /**
   * Whether the select is disabled.
   */
  disabled?: boolean;
  /**
   * Whether the input is invalid.
   */
  invalid?: boolean;
  /**
   * Loading state of Select, which will render a spinner at bottom of the option list.
   */
  loading?: boolean;
  /**
   * Name of <input> element, is used to refer to the form data for submission.
   */
  name?: string;
  /**
   * Content to render when filtering items returns zero results.
   */
  noResults?: ReactNode;
  /**
   * Blur event handler.
   */
  onBlur?: (e: FocusEvent<HTMLInputElement>) => void;
  /**
   * onChange event handler.
   */
  onChange: (value?: string | number) => void;
  /**
   * Callback to allow to create new option when option not found based on query (only when the callback is defined).
   */
  onCreateNewOption?: (optionText: string) => void;
  /**
   * Focus event handler.
   */
  onFocus?: (e: FocusEvent<HTMLInputElement>) => void;
  /**
   * Callback invoked when the query string changes.
   */
  onQueryChange?: (query?: string) => void;
  /**
   * Handle scroll event when scrolling to the bottom of the option list.
   */
  onScrollListToBottom?: () => void;
  /**
   * Additonal inline style for option menu dropdown.
   */
  optionMenuStyle?: CSSProperties;
  /**
   * Customise option renderer.
   */
  optionRenderer?: ({
    option,
    index,
  }: {
    index: number;
    option: OptionType;
  }) => ReactElement;
  /**
   * An array of options to be selected.
   */
  options:
    | {
        disabled?: boolean;
        helpText?: string;
        text: string;
        value: string | number;
      }[]
    | {
        category: string;
        options: {
          disabled?: boolean;
          helpText?: string;
          text: string;
          value: string | number;
        }[];
      }[];
  /**
   * Placeholder text in the absence of any value.
   */
  placeholder?: string;
  /**
   * Name of Icon or an Icon element to render on the left side of the input.
   */
  prefix?: IconName | ReactElement;
  /**
   * Query string to filter options. This value is controlled: its state if defined must be managed externally.
   */
  query?: string;
  /**
   * The size of the input box.
   */
  size?: 'small' | 'medium' | 'large';
  /**
   * Current selected value.
   */
  value?: string | number;
}

const Select = ({
  options,
  value,
  onBlur,
  onChange,
  onFocus,
  query,
  onQueryChange,
  optionRenderer,
  noResults,
  disabled = false,
  size = 'medium',
  invalid,
  placeholder,
  prefix,
  onScrollListToBottom,
  loading,
  name,
  onCreateNewOption,
  id,
  className,
  style,
  autoComplete,
  optionMenuStyle,
  clearable = false,
  'data-test-id': dataTestId,
}: SelectProps): ReactElement => {
  const menuRef = useRef<HTMLDivElement | null>(null);
  const activeItemRef = useRef<HTMLLIElement | null>(null);
  const [isAutoFilled, setIsAutoFilled] = useState<boolean>(false);
  const [wrapperElement, setWrapperElement] = useState<HTMLDivElement | null>(
    null
  );
  const [optionMenuWidth, setOptionMenuWidth] = useState<number>();
  const [removeShown, setRemoveShown] = useState<boolean>(false);

  const onScrollToBottom = useCallback((): void => {
    const isAtBottom = checkAtBottom(menuRef.current);
    if (
      isAtBottom === true &&
      loading !== true &&
      onScrollListToBottom !== undefined
    ) {
      onScrollListToBottom();
    }
  }, [loading, onScrollListToBottom]);

  const onMouseEnterInput = useCallback((): void => {
    if (value !== undefined && disabled !== true) {
      setRemoveShown(true);
    }
  }, [value, disabled]);

  const onMouseLeaveInput = useCallback((): void => {
    if (removeShown === true) {
      setRemoveShown(false);
    }
  }, [removeShown]);

  const mappedOptions = useMemo(() => {
    return filterGroupedOptions(optionPredicate(query), mapOptions(options));
  }, [options, query]);

  const flatOptions = useMemo(
    () =>
      pipe(
        options,
        mapOptions,
        arrayMap(opt => opt.options),
        flat
      ),
    [options]
  );

  const readonly = onQueryChange === undefined;
  const hasResults = mappedOptions.length > 0;

  const selectedItem = useMemo(
    () => flatOptions.find(item => item.value === value),
    [flatOptions, value]
  );
  const selectedItemText = selectedItem !== undefined ? selectedItem.text : '';

  useEffect(() => {
    pipe(
      fromNullable(menuRef.current),
      map(el => {
        const offsetTop = getItemOffsetTop(activeItemRef.current);
        if (offsetTop !== undefined) {
          const menuEl = el;
          menuEl.scrollTop = offsetTop;
        }
      }),
      getOrElse(noop)
    );
  }, [selectedItem]);

  const resizeCallback = useCallback(
    ({ width }) => {
      setOptionMenuWidth(width);
    },
    [setOptionMenuWidth]
  );

  useResizeObserver(resizeCallback, wrapperElement);

  return (
    <Downshift
      itemToString={(item): string => (item !== null ? item.text : '')}
      onChange={(newItem): void => {
        if (newItem !== null) {
          if (hasResults === false && onCreateNewOption !== undefined) {
            onCreateNewOption(newItem.text);
          } else {
            onChange(newItem.value);
          }
        }
        if (onQueryChange !== undefined && query !== undefined) {
          onQueryChange(undefined);
        }
      }}
      selectedItem={selectedItem !== undefined ? selectedItem : null}
    >
      {({
        getRootProps,
        getInputProps,
        getMenuProps,
        getItemProps,
        isOpen,
        toggleMenu,
        highlightedIndex,
      }): ReactElement => {
        const onClick = (): void => toggleMenu({ isOpen: !isOpen });
        const onInputChange = (e: ChangeEvent): void => {
          if (onQueryChange !== undefined) {
            const newQuery = (e.target as HTMLInputElement).value;
            onQueryChange(newQuery);
            if (isAutoFilled === true) {
              const foundItem = flatOptions.find(
                item => item.text === newQuery
              );
              if (foundItem !== undefined) onChange(foundItem.value);
            }
          }

          if (isOpen === false && isAutoFilled === false) {
            toggleMenu({ isOpen: true });
          }
          setIsAutoFilled(false);
        };
        const inputProps = getInputProps({
          onKeyDown: (e: KeyboardEvent): void => {
            if (e.key === 'Unidentified') setIsAutoFilled(true);
          },
          ref: undefined,
        });

        const selectInput = (
          <InputWrapper
            onMouseEnter={clearable === true ? onMouseEnterInput : undefined}
            onMouseLeave={clearable === true ? onMouseLeaveInput : undefined}
          >
            <Input
              {...inputProps}
              prefix={prefix}
              suffix={
                <SuffixIcon
                  loading={loading}
                  open={isOpen}
                  onChange={onChange}
                  removeShown={removeShown}
                  setRemoveShown={setRemoveShown}
                />
              }
              disabled={disabled}
              invalid={invalid}
              placeholder={placeholder}
              readonly={readonly}
              name={name}
              size={size}
              value={query !== undefined ? query : selectedItemText}
              autoComplete={autoComplete}
              onChange={onInputChange}
              onFocus={onFocus}
              onBlur={(e: FocusEvent<HTMLInputElement>): void => {
                if (onBlur !== undefined) {
                  onBlur(e);
                }
                if (onQueryChange !== undefined && query !== undefined) {
                  onQueryChange(undefined);
                }
              }}
              id={id}
            />
          </InputWrapper>
        );
        const optionMenu = (
          <MenuWrapper
            {...getMenuProps({ ref: menuRef })}
            onScroll={onScrollToBottom}
            style={{ width: optionMenuWidth, ...optionMenuStyle }}
          >
            <Menu>
              {mappedOptions.map((opt, catIndex) => {
                const accumulatedIndex = getAccumulatedIndex(
                  mappedOptions,
                  catIndex
                );
                return (
                  <React.Fragment key={opt.category}>
                    {opt.category !== '' && (
                      <CategoryWrapper>
                        <Typography.Text
                          tagName="span"
                          fontSize={12}
                          fontWeight="semi-bold"
                          intent="subdued"
                        >
                          {opt.category}
                        </Typography.Text>
                      </CategoryWrapper>
                    )}
                    {opt.options.map((item, index) => {
                      const actualIndex = accumulatedIndex + index;
                      const isActiveItem = item.value === selectedItem?.value;
                      const ariaProps =
                        item.disabled === true
                          ? {}
                          : {
                              ...getItemProps({
                                item,
                                index: actualIndex,
                                ref:
                                  isActiveItem === true
                                    ? activeItemRef
                                    : undefined,
                              }),
                            };

                      return (
                        <Menu.Item
                          key={item.value}
                          text={
                            optionRenderer !== undefined
                              ? optionRenderer({ option: item, index })
                              : item.text
                          }
                          focused={actualIndex === highlightedIndex}
                          active={isActiveItem}
                          disabled={item.disabled}
                          textElement={
                            item.helpText !== undefined && (
                              <Typography.Text
                                tagName="span"
                                intent={isActiveItem ? 'main' : 'subdued'}
                              >
                                {item.helpText}
                              </Typography.Text>
                            )
                          }
                          {...ariaProps}
                        />
                      );
                    })}
                    {catIndex < mappedOptions.length - 1 && <Divider />}
                  </React.Fragment>
                );
              })}
            </Menu>
            {hasResults === false &&
              loading !== true &&
              onCreateNewOption !== undefined &&
              query !== undefined && (
                <Menu.Item
                  icon="add"
                  text={query}
                  focused={highlightedIndex === 0}
                  {...getItemProps({
                    item: { value: query, text: query },
                    index: 0,
                  })}
                />
              )}
            {hasResults === false &&
              onCreateNewOption === undefined &&
              noResults}
          </MenuWrapper>
        );

        return (
          <SelectWrapper
            {...getRootProps({ refKey: 'ref' })}
            onClick={disabled === true ? undefined : onClick}
            className={className}
            style={style}
            data-test-id={dataTestId}
            ref={setWrapperElement}
          >
            <Dropdown
              target={selectInput}
              content={optionMenu}
              open={isOpen}
              onClose={noop}
              keepContentMounted
            />
          </SelectWrapper>
        );
      }}
    </Downshift>
  );
};

export default Select;
