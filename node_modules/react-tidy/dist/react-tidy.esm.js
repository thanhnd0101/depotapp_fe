import React, { useMemo } from 'react';

function isFunction(x) {
  return !!x && {}.toString.call(x) === '[object Function]';
}

function isInBrowser() {
  return typeof window === 'object' && typeof document === 'object';
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

var createMemoryStorage = function createMemoryStorage() {
  return new MemoryStorage();
};

var MemoryStorage = /*#__PURE__*/function () {
  function MemoryStorage() {
    this.memory = {};
  }

  var _proto = MemoryStorage.prototype;

  _proto.getItem = function getItem(key) {
    return this.memory[key] || null;
  };

  _proto.setItem = function setItem(key, value) {
    this.memory[key] = value;
  };

  _proto.removeItem = function removeItem(key) {
    delete this.memory[key];
  };

  _proto.key = function key(index) {
    var keys = Object.keys(this.memory);
    return keys[index] || null;
  };

  _proto.clear = function clear() {
    this.memory = {};
  };

  _createClass(MemoryStorage, [{
    key: "length",
    get: function get() {
      return Object.keys(this.memory).length;
    }
  }]);

  return MemoryStorage;
}();

var defaultStorage;

if (isInBrowser()) {
  defaultStorage = window.localStorage;
} else {
  defaultStorage = /*#__PURE__*/createMemoryStorage();
}

function getDefaultStorage() {
  return defaultStorage;
}
function setDefaultStorage(storage) {
  defaultStorage = storage;
}

function useIsMounted() {
  var ref = React.useRef(true);
  React.useEffect(function () {
    return function () {
      ref.current = false;
    };
  }, []);
  return React.useCallback(function () {
    return ref.current;
  }, []);
}

function useStorage(key, defaultValue, getStorage) {
  if (defaultValue === void 0) {
    defaultValue = null;
  }

  if (getStorage === void 0) {
    getStorage = getDefaultStorage();
  }

  var isMounted = useIsMounted();
  var storage = useMemo(function () {
    if (!isInBrowser()) return createMemoryStorage();
    if (isFunction(getStorage)) return getStorage();
    return getStorage;
  }, [getStorage]);
  var initialValue = useMemo(function () {
    var storedString = storage.getItem(key);
    return storedString === null ? defaultValue : JSON.parse(storedString);
  }, [storage, key, defaultValue]);

  var _React$useState = React.useState(initialValue),
      value = _React$useState[0],
      setValue = _React$useState[1];

  React.useEffect(function () {
    storage.setItem(key, JSON.stringify(initialValue));
  }, [key, initialValue]);
  var setItem = React.useCallback(function (newValue) {
    if (isFunction(newValue)) {
      newValue = newValue(value);
    }

    if (newValue === null) {
      storage.removeItem(key);
    } else {
      storage.setItem(key, JSON.stringify(newValue));
    }

    if (isMounted()) {
      setValue(newValue);
    }
  }, [storage, key, value]);
  return [value, setItem];
}

function useRefresh() {
  var _React$useState = React.useState(0),
      setVersion = _React$useState[1];

  var isMounted = useIsMounted();
  return function () {
    if (isMounted()) {
      setVersion(function (x) {
        return x + 1;
      });
    }
  };
}

var proxySymbol = /*#__PURE__*/Symbol();
function makeProxy(target, notify) {
  if (target[proxySymbol] === true) {
    return target;
  }

  return new Proxy(target, {
    get: makeTrap('get', notify),
    defineProperty: makeTrap('defineProperty', notify),
    deleteProperty: makeTrap('deleteProperty', notify)
  });
}

function makeTrap(trap, notify) {
  return function () {
    if (trap === 'get' && (arguments.length <= 1 ? undefined : arguments[1]) === proxySymbol) {
      return true;
    }

    var original = Reflect[trap];
    var result = original.apply(void 0, arguments);

    if (trap === 'get' && typeof result === 'object' && result !== null) {
      result = makeProxy(result, notify);
    }

    if (trap !== 'get') {
      notify();
    }

    return result;
  };
}

function useInstance(Class) {
  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  var refresh = useRefresh();
  var instance = React.useMemo(function () {
    return makeProxy(_construct(Class, args), refresh);
  }, args);
  React.useEffect(function () {
    var currentInstance = instance;
    return function () {
      return currentInstance.cleanup && currentInstance.cleanup();
    };
  }, args);
  return instance;
}

function usePrevious(value, count) {
  if (count === void 0) {
    count = 1;
  }

  var _React$useState = React.useState([]),
      history = _React$useState[0],
      setHistory = _React$useState[1];

  React.useEffect(function () {
    if (history.length > count) {
      history.pop();
    }

    setHistory([value].concat(history));
  }, [value]);
  return history.slice(1);
}

export { createMemoryStorage, getDefaultStorage, setDefaultStorage, useInstance, useIsMounted, usePrevious, useRefresh, useStorage };
//# sourceMappingURL=react-tidy.esm.js.map
